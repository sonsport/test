// =================================================================================
// This is auto-generated by GoFrame CLI tool only once. Fill this file as you wish.
// =================================================================================

package dao

import (
	"context"
	"database/sql"
	"time"

	"github.com/gogf/gf/v2/database/gdb"
	"github.com/gogf/gf/v2/frame/g"
	"github.com/gogf/gf/v2/util/gconv"

	"fuya-ark/internal/consts"
	"fuya-ark/internal/dao/internal"
	"fuya-ark/internal/model"
	"fuya-ark/internal/model/do"
	"fuya-ark/internal/model/entity"
)

// internalGuildAnchorDao is internal type for wrapping internal DAO implements.
type internalGuildAnchorDao = *internal.GuildAnchorDao

// guildAnchorDao is the data access object for table guild_anchor.
// You can define custom methods on it to extend its functionality as you wish.
type guildAnchorDao struct {
	internalGuildAnchorDao
}

var (
	// GuildAnchor is globally public accessible object for table guild_anchor operations.
	GuildAnchor = guildAnchorDao{
		internal.NewGuildAnchorDao(),
	}
)

// Fill with you ideas below.

func (m *guildAnchorDao) GetGuildAnchor(ctx context.Context, userId int64, status int) (
	data *entity.GuildAnchor, err error) {
	err = g.DB().Model(GuildAnchor.Table()).Ctx(ctx).
		Where("user_id", userId).
		Where("status", status).
		//Cache(gdb.CacheOption{
		//	Duration: time.Hour, Name: oss.MysqlAnchorGuildByUserId + gconv.String(userId) + gconv.String(status)},
		//).
		Scan(&data)
	return data, err
}

func (m *guildAnchorDao) CreateGuildInfo(ctx context.Context, anchor do.GuildAnchor) (err error) {
	anchor.CreateTime = time.Now().Unix()
	anchor.UpdateTime = time.Now().Unix()
	anchor.Status = 0
	_, err = m.DB().Model().Ctx(ctx).Data(m).Save()
	if err != nil {
		return err
	}

	return nil
}

func (m *guildAnchorDao) GetGuildServiceIdByUserId(ctx context.Context, userId int64, status int) (
	data *guildAnchorDao, err error) {
	sqlStr := `
			select gi.* from guild_info gi
            left join guild_anchor ga on gi.id=ga.guild_id
			where gi.status=1
			and ga.user_id=?
			and ga.status=?
	`
	err = m.DB().Ctx(ctx).GetScan(ctx, &data, sqlStr, userId, status)
	return data, err
}

func (m *guildAnchorDao) GetGuildInfo(ctx context.Context, id int64) (guild *guildAnchorDao, err error) {
	err = m.DB().Model().Ctx(ctx).Where("id=?", id).Scan(&guild)
	if err != nil && err != sql.ErrNoRows {
		return nil, err
	}
	return
}

func (m *guildAnchorDao) GetGuildOkInfo(ctx context.Context, id int64) (guild *guildAnchorDao, err error) {
	err = m.DB().Model().Ctx(ctx).
		Where("id=?", id).Where("status", consts.GuildStatusOk).Scan(&guild)
	if err != nil && err != sql.ErrNoRows {
		return nil, err
	}
	return
}

func (m *guildAnchorDao) GetGuildInfoById(ctx context.Context, id int64) (guild *guildAnchorDao, err error) {
	err = m.DB().Model().Ctx(ctx).Cache(
		gdb.CacheOption{
			Duration: time.Minute * 1,
			Name:     consts.MysqlGuildInfoById + gconv.String(id),
			Force:    false,
		}).
		Where("id", id).Scan(&guild)
	if err != nil && err != sql.ErrNoRows {
		return nil, err
	}
	return guild, nil
}

func (m *guildAnchorDao) GetGuildInfoByIds(ctx context.Context, ids []int64) ([]*entity.GuildInfo, error) {
	var res []*entity.GuildInfo
	err := m.DB().Model().Ctx(ctx).
		Where("id in (?) and status=1", ids).Scan(&res)
	return res, err
}

func (m *guildAnchorDao) GetGuildInfoByUserId(ctx context.Context, userId int64) (guild *guildAnchorDao, err error) {
	err = m.DB().Model().Ctx(ctx).Where("user_id=?", userId).
		Where("status=?", consts.GuildStatusOk).Scan(&guild)
	if err != nil && err != sql.ErrNoRows {
		return nil, err
	}
	return guild, nil
}

func (m *guildAnchorDao) GetGuildInfoByStatus(ctx context.Context) (guild []*entity.GuildAnchor, err error) {
	err = m.DB().Model().Ctx(ctx).Where("status=?", consts.GuildStatusOk).Scan(&guild)
	if err != nil && err != sql.ErrNoRows {
		return nil, err
	}
	return guild, nil
}

func (m *guildAnchorDao) AddMemberCount(ctx context.Context, id int) (err error) {
	if _, err = m.DB().Model().Ctx(ctx).Where("id", id).
		Increment("views", 1); err != nil {
		return err
	}
	return nil
}

func (m *guildAnchorDao) DecrMemberCount(ctx context.Context, id int) (err error) {
	if _, err = m.DB().Model().Ctx(ctx).
		Where("id", id).
		Increment("views", -1); err != nil {
		return err
	}

	return nil
}

func (m *guildAnchorDao) CountGuildByServerId(ctx context.Context,
	serverId, startTime, endTime int64) (res *model.GuildStatistics, err error) {
	sqlStr := `
			select
				count(server_id) as guild_num,
				count(if(create_time >=` + gconv.String(startTime) + ` and create_time<` + gconv.String(endTime) + `,id,null)) as new_guild_num
			from guild_info
			where server_id = ? and status=1
	`
	re, err := m.DB().Ctx(ctx).GetOne(ctx, sqlStr, serverId)
	re.Struct(&res)
	return
}

// func (m *guildAnchorDao) CountWeekNewGuild(ctx context.Context, serverId, beginTime, endTime int64) (guildNum int, err error) {
// 	guildNum, err = storage.HimiMysqlClient.Model(m.TableName()).Ctx(ctx).
// 		Where("server_id=? and create_time >=? and create_time<?", serverId, beginTime, endTime).Count()
// 	return
// }

func (m *guildAnchorDao) GetGuildInfosByServreId(ctx context.Context, serverId int64) (guilds []entity.GuildInfo, err error) {
	err = m.DB().Model().Ctx(ctx).Where("server_id=? and status=1", serverId).Scan(&guilds)
	return
}

func (m *guildAnchorDao) GetAnchorCountByStartLevel(ctx context.Context, userId int64) (count int) {
	count, _ = m.DB().Ctx(ctx).GetCount(ctx,
		`SELECT COUNT(ga.user_id) from guild_info gi
				LEFT JOIN guild_anchor ga on gi.id=ga.guild_id 
				WHERE ga.star_level>0
				and gi.status=1
				and ga.status=1
				and gi.user_id=?
				GROUP BY gi.id`, userId)
	return count
}

func (m *guildAnchorDao) GetGuildInfoByAnchorId(ctx context.Context, userId int64) (data entity.GuildInfo, err error) {
	err = m.DB().Ctx(ctx).Model(m.Table(), "gi").
		LeftJoin("guild_anchor ga", "ga.guild_id=gi.id").
		Where("ga.user_id=? and ga.status=1 and gi.status=1", userId).
		Fields("gi.*").Scan(&data)
	return data, err
}

// GetAnchorLastLiveByTime 主播最后一次直播在那个时间范围
func (m *guildAnchorDao) GetAnchorLastLiveByTime(ctx context.Context, startTime, endTime int64) (resp []model.AnchorLastLiveResp, err error) {
	sqlStr := `
		select 
			gi.user_id as master_id,
			ui.nickname as master_name,
			gi.server_id ,
			ga.user_id ,
			(
			select
			max(rl.begin_time)
			from
			room_live rl
			where
			rl.user_id = ga.user_id
			and rl.begin_time between ? and ?
			and rl.status in (2, 3, 4, 6, 9)) as last_live_time
		from
		guild_anchor ga 
			left join guild_info gi on ga.guild_id = gi.id
			left join user_info ui on gi.user_id = ui.user_id
		WHERE EXISTS(
			SELECT room_id from room_live rl  WHERE rl.user_id= ga.user_id and rl.begin_time between ? and ? and rl.status in (2,3,4,6,9))
		and not EXISTS (
			SELECT room_id from room_live rl  WHERE rl.user_id= ga.user_id and rl.begin_time > ? and rl.status in (2,3,4,6,9))
		and gi.status =1
		and ga.star_level >0   
		and ga.status=1 `
	err = m.DB().Ctx(ctx).GetScan(ctx, &resp, sqlStr, startTime, endTime, startTime, endTime, endTime)
	return
}

func (m *guildAnchorDao) GetGuildByUserId(ctx context.Context, userId int64) (guild *guildAnchorDao, err error) {
	sqlStr := "SELECT gi.* from guild_anchor ga LEFT JOIN guild_info gi on gi.id=ga.guild_id WHERE ga.user_id=? and ga.status=1"
	re, err := m.DB().Ctx(ctx).GetOne(ctx, sqlStr, userId)
	re.Struct(&guild)
	return
}
